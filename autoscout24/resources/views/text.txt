

**1. Configuration des Queues de Laravel :**

Assurez-vous que votre configuration de queue est prête. Vous pouvez utiliser le driver `sync` pour un traitement immédiat (utile pour le développement) ou configurer un vrai worker de queue (comme `database`, `redis`, `beanstalkd`) pour le traitement en arrière-plan en production.

* **`.env` :**
    ```dotenv
    QUEUE_CONNECTION=sync # Pour le développement, changez pour database, redis, etc. en production
    ```
* **Migration pour le driver `database` (si vous l'utilisez) :**
    ```bash
    php artisan queue:table
    php artisan migrate
    ```
* **Démarrer le worker de queue (pour les drivers autres que `sync`) :**
    ```bash
    php artisan queue:work
    ```

**2. Création d'un Job Laravel :**

Créez un Job qui encapsulera la logique de lecture et de traitement du fichier Excel.

```bash
php artisan make:job ProcessExcelImport
```

Dans `app/Jobs/ProcessExcelImport.php` :

```php
<?php

namespace App\Jobs;

use App\Services\ExcelLineReaderService;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldBeUnique;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Session;

class ProcessExcelImport implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    protected string $filePath;
    protected string $processId;
    protected int $totalRows;

    /**
     * Create a new job instance.
     *
     * @param string $filePath
     * @param string $processId
     * @param int $totalRows
     * @return void
     */
    public function __construct(string $filePath, string $processId, int $totalRows)
    {
        $this->filePath = $filePath;
        $this->processId = $processId;
        $this->totalRows = $totalRows;
    }

    /**
     * Execute the job.
     *
     * @param  \App\Services\ExcelLineReaderService  $excelLineReaderService
     * @return void
     */
    public function handle(ExcelLineReaderService $excelLineReaderService)
    {
        Log::info("Job ProcessExcelImport started for ID: {$this->processId}");

        $startRow = 1;
        $maxRows = null;
        $processedRows = 0;

        $excelLineReaderService->readExcelLineByLine($this->filePath, function (array $rowData) use ($this->processId, &$processedRows) {
            $processedRows++;
            $percentage = $this->totalRows > 0 ? floor(($processedRows / $this->totalRows) * 100) : 0;
            Session::put("excel_import_progress_{$this->processId}", ['totalRows' => $this->totalRows, 'processedRows' => $processedRows, 'percentage' => $percentage]);

            Log::info("Job Processing line (ID: {$this->processId}):", $rowData);
            // Votre logique de traitement de la ligne (par exemple, enregistrer en base de données)
        }, $startRow, $maxRows);

        Session::forget("excel_import_progress_{$this->processId}");
        Log::info("Job ProcessExcelImport finished for ID: {$this->processId}");
    }
}
```

**Modifications dans le Job :**

* Le Job implémente `ShouldQueue` pour indiquer qu'il doit être exécuté en arrière-plan.
* Le constructeur reçoit le chemin du fichier, l'ID de traitement et le nombre total de lignes.
* La méthode `handle` contient la logique de lecture du fichier Excel ligne par ligne, en utilisant votre `ExcelLineReaderService`.
* La progression est mise à jour dans la session de la même manière qu'auparavant.

**3. Modification du Contrôleur (`ImportController.php`) :**

Modifiez votre contrôleur pour télécharger le fichier et dispatcher le Job.

```php
<?php

namespace App\Http\Controllers;

use App\Jobs\ProcessExcelImport;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Session;
use PhpOffice\PhpSpreadsheet\IOFactory;

class ImportController extends Controller
{
    public function importExcelInBackground(Request $request)
    {
        $request->validate([
            'excel_file' => 'required|file|mimes:xlsx,xls',
        ]);

        $file = $request->file('excel_file');
        $filename = uniqid('excel_') . '.' . $file->getClientOriginalExtension();
        $filePath = $file->storeAs('imports', $filename); // Stocker le fichier dans storage/app/imports

        $processId = uniqid();
        Session::put("excel_import_progress_{$processId}", ['totalRows' => 0, 'processedRows' => 0, 'percentage' => 0]);

        // Obtenir le nombre total de lignes (peut être optimisé)
        $totalRows = 0;
        try {
            $spreadsheet = IOFactory::load(storage_path('app/' . $filePath));
            $worksheet = $spreadsheet->getActiveSheet();
            $totalRows = $worksheet->getHighestRow();
            $spreadsheet->disconnectWorksheets();
            unset($spreadsheet);
            Session::put("excel_import_progress_{$processId}", ['totalRows' => $totalRows, 'processedRows' => 0, 'percentage' => 0]);
        } catch (\Exception $e) {
            Log::error("Erreur lors de la récupération du nombre total de lignes : " . $e->getMessage());
            Session::put("excel_import_progress_{$processId}", ['totalRows' => 0, 'processedRows' => 0, 'percentage' => 0]);
        }

        // Dispatcher le Job pour le traitement en arrière-plan
        ProcessExcelImport::dispatch($filePath, $processId, $totalRows);

        return redirect()->route('import.progress.page', ['process_id' => $processId])
            ->with('info', 'L\'importation du fichier Excel a commencé en arrière-plan. Vous pouvez suivre la progression ci-dessous.');
    }

    public function showImportProgressPage(Request $request)
    {
        $processId = $request->query('process_id');
        return view('import_progress', ['processId' => $processId]);
    }

    public function getImportProgress(Request $request)
    {
        $processId = $request->query('process_id');
        $progress = Session::get("excel_import_progress_{$processId}");

        return response()->json($progress ?? ['percentage' => 0, 'processedRows' => 0, 'totalRows' => 0]);
    }
}
```

**Modifications dans le Contrôleur :**

* **`importExcelInBackground` :**
    * Télécharge le fichier Excel dans le storage (`storage/app/imports`).
    * Génère un `processId` unique.
    * Initialise l'état de la progression dans la session.
    * Obtient le nombre total de lignes (similaire à avant).
    * **Dispatche le Job `ProcessExcelImport`** avec le chemin du fichier, l'ID de traitement et le nombre total de lignes.
    * Redirige l'utilisateur vers une page de suivi de la progression (`import.progress.page`).
* **`showImportProgressPage` :** Affiche une page dédiée pour suivre la progression, en passant l'`processId`.
* La méthode `getImportProgress` reste la même pour récupérer l'état de la progression depuis la session.

**4. Création de la Vue de Suivi de la Progression (`resources/views/import_progress.blade.php`) :**

```blade
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Suivi de l'Importation Excel</title>
    <style>
        #progress-container {
            margin-top: 20px;
            border: 1px solid #ccc;
            padding: 10px;
        }
        #progress-bar {
            width: 0%;
            height: 20px;
            background-color: #4CAF50;
        }
    </style>
</head>
<body>
    <h1>Suivi de l'Importation Excel</h1>

    @if (session('info'))
        <div style="color: blue;">{{ session('info') }}</div>
    @endif

    <div id="progress-container">
        <div id="progress-bar"></div>
        <p>Chargement : <span id="progress-percentage">0%</span> (<span id="progress-processed">0</span> / <span id="progress-total">0</span>)</p>
    </div>

    <script>
        const progressContainer = document.getElementById('progress-container');
        const progressBar = document.getElementById('progress-bar');
        const progressPercentage = document.getElementById('progress-percentage');
        const progressProcessed = document.getElementById('progress-processed');
        const progressTotal = document.getElementById('progress-total');
        const processId = '{{ $processId }}';
        let intervalId;

        function fetchProgress() {
            fetch(`/import/progress?process_id=${processId}`)
                .then(response => response.json())
                .then(progress => {
                    progressBar.style.width = `${progress.percentage}%`;
                    progressPercentage.textContent = `${progress.percentage}%`;
                    progressProcessed.textContent = progress.processedRows;
                    progressTotal.textContent = progress.totalRows;
                    if (progress.percentage === 100) {
                        clearInterval(intervalId);
                        alert('Importation terminée !');
                        // Rediriger ou afficher un message de succès
                    }
                })
                .catch(error => {
                    clearInterval(intervalId);
                    console.error('Erreur lors de la récupération de la progression:', error);
                    alert('Erreur lors de l\'importation.');
                });
        }

        // Interroger l'état de la progression toutes les secondes
        intervalId = setInterval(fetchProgress, 1000);
    </script>
</body>
</html>
```

**5. Création des Routes :**

```php
use App\Http\Controllers\ImportController;
use Illuminate\Support\Facades\Route;

Route::post('/import/excel/background', [ImportController::class, 'importExcelInBackground'])->name('import.excel.background');
Route::get('/import/progress/page', [ImportController::class, 'showImportProgressPage'])->name('import.progress.page');
Route::get('/import/progress', [ImportController::class, 'getImportProgress'])->name('import.progress');
```

**Explication du Fonctionnement :**

1.  L'utilisateur soumet le formulaire sur la page d'importation.
2.  Le contrôleur télécharge le fichier, initialise l'état de la progression dans la session et dispatche le Job `ProcessExcelImport`.
3.  L'utilisateur est redirigé vers la page de suivi de la progression.
4.  La page de suivi utilise JavaScript pour interroger l'endpoint `/import/progress` toutes les secondes, en utilisant l'`processId` récupéré.
5.  Le contrôleur renvoie l'état de la progression depuis la session.
6.  Le JavaScript met à jour l'interface utilisateur en conséquence.
7.  Le Job s'exécute en arrière-plan, lisant et traitant le fichier Excel ligne par ligne et mettant à jour la progression dans la session.
8.  Lorsque le Job termine, la session est nettoyée, et l'interface utilisateur peut être mise à jour pour indiquer la fin du processus.

**Points Importants :**

* **Configuration des Queues :** Assurez-vous d'avoir configuré et démarré un worker de queue pour que le Job s'exécute en arrière-plan.
* **Gestion des Erreurs :** Gérez correctement les erreurs dans le Job et dans l'interface utilisateur.
* **Nettoyage de la Session :** Il est important de nettoyer la session après la fin du traitement pour éviter l'accumulation de données.
* **Sécurité :** Soyez conscient des implications de sécurité du stockage de fichiers téléchargés et de la gestion des sessions.
* **Optimisation :** Pour les fichiers très volumineux, vous pourriez envisager des optimisations supplémentaires, comme la lecture du fichier par blocs directement depuis le système de fichiers dans le Job.

Cette approche utilisant les Queues de Laravel est la manière recommandée pour gérer les tâches longues en arrière-plan et offrir une expérience utilisateur réactive. N'oubliez pas d'adapter les noms de routes, de vues et les styles CSS à votre application.